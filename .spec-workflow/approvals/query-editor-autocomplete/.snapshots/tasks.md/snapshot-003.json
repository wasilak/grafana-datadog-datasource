{
  "id": "snapshot_1764929533374_nhn6w8wk5",
  "approvalId": "approval_1764929514715_d0bm6flpf",
  "approvalTitle": "Query Editor Autocomplete - Tasks Document (Revised with dependency first)",
  "version": 3,
  "timestamp": "2025-12-05T10:12:13.373Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Tasks: Query Editor Autocomplete\n\n## Task 0: Install official Datadog API client dependency\n\n- [ ] 0. Add @datadog/datadog-api-client dependency to package.json\n  - File: package.json (modify)\n  - Add @datadog/datadog-api-client to dependencies\n  - Run yarn install to verify\n  - Purpose: Make official client available for implementation\n  - _Leverage: Existing package.json\n  - _Requirements: All tasks requiring API integration (tasks 4+)\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps engineer | Task: Add @datadog/datadog-api-client to package.json dependencies, run yarn install, verify dependency resolves without conflicts | Restrictions: Use latest stable version compatible with Node.js >=14 | _Leverage: package.json, yarn ecosystem | _Requirements: All tasks | Success: Dependency added, yarn.lock updated, no version conflicts, ready for subsequent tasks\n\n## Task 1: Set up core types and interfaces\n\n- [ ] 1. Define autocomplete types in src/types.ts\n  - File: src/types.ts\n  - Add QueryContext, AutocompleteState, and CompletionItem interfaces\n  - Purpose: Establish type safety for autocomplete feature\n  - _Leverage: Existing types.ts, Grafana @grafana/data CompletionItem\n  - _Requirements: All requirements use these types as foundation\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: TypeScript developer specializing in Grafana plugin development | Task: Add comprehensive TypeScript interfaces to src/types.ts for the autocomplete feature (QueryContext, AutocompleteState, CompletionCache) based on the design document, extending Grafana's CompletionItem type for consistency | Restrictions: Do not modify existing interfaces, maintain backward compatibility with current query types | _Leverage: src/types.ts (existing), @grafana/data CompletionItem | _Requirements: Design section \"Data Models\" and \"Components and Interfaces\" | Success: All three interfaces compile without errors, properly typed with strict null checks, used throughout autocomplete implementation\n\n## Task 2: Create suggestion utilities (parser, suggestions, api)\n\n- [ ] 2. Create src/utils/autocomplete/parser.ts\n  - File: src/utils/autocomplete/parser.ts (new)\n  - Implement parseQuery function to detect cursor context\n  - Identify metric, aggregation, tag, and tag_value contexts\n  - Purpose: Analyze query structure for context-aware suggestions\n  - _Leverage: Pure functions, no external dependencies\n  - _Requirements: Requirement 2, 3, 4 (tag, aggregation, metric suggestions)\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: TypeScript developer specializing in string parsing and query analysis | Task: Create src/utils/autocomplete/parser.ts with parseQuery function that analyzes Datadog query syntax, detects cursor position context (metric/aggregation/tag/tag_value), extracts metric name and existing tags based on design document structure | Restrictions: Keep function pure (no side effects), handle edge cases (empty queries, special characters, cursor at boundaries), performance target <10ms per parse | _Leverage: Design \"Query Parsing\" section, QueryContext interface from task 1 | _Requirements: Requirements 2, 3, 4 (context detection for suggestions) | Success: parseQuery correctly identifies all context types, handles edge cases, executes under 10ms, unit tests cover all branches\n\n- [ ] 3. Create src/utils/autocomplete/suggestions.ts\n  - File: src/utils/autocomplete/suggestions.ts (new)\n  - Implement generateSuggestions function\n  - Create static aggregation list and filter logic\n  - Purpose: Transform parsed context and API data into CompletionItems\n  - _Leverage: Pure functions, CompletionItem type\n  - _Requirements: Requirement 3 (aggregations), Requirement 2 (metrics), Requirement 4 (tags)\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: TypeScript developer specializing in suggestion algorithms | Task: Create src/utils/autocomplete/suggestions.ts with generateSuggestions function that converts parsed QueryContext and fetched data into Grafana CompletionItem array, including metric names, aggregation functions (avg, sum, min, max, count, etc.), and tag suggestions with proper filtering and sorting | Restrictions: Keep function pure, avoid duplicates in suggestions, limit to 100 items max, filter out already-used tags | _Leverage: QueryContext and CompletionItem types from task 1, parser.ts from task 2, design \"Suggestion Utilities\" section | _Requirements: Requirements 2, 3, 4 (all suggestion types) | Success: Suggestions are properly typed, duplicates removed, performance acceptable, all context types generate appropriate suggestions, unit tests verify filtering logic\n\n- [ ] 4. Create src/utils/autocomplete/api.ts\n  - File: src/utils/autocomplete/api.ts (new)\n  - Import and configure official @datadog/datadog-api-client\n  - Implement fetchMetricsFromDatadog and fetchTagsForMetric functions\n  - Add error handling and caching logic\n  - Purpose: Fetch suggestion data from Datadog API using official client\n  - _Leverage: @datadog/datadog-api-client package, AutocompleteCache interface\n  - _Requirements: All suggestions require API data (Requirements 2, 3, 4)\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend developer with Datadog API expertise | Task: Create src/utils/autocomplete/api.ts using official @datadog/datadog-api-client package (v1 MetricsApi, TagsApi) to fetch metric names and tags with 2-second timeout, implement 30-second TTL cache, handle 401/403 auth errors gracefully, and cancel in-flight requests on unmount | Restrictions: Must use official client not HTTP calls, timeout must be enforced with AbortController, cache TTL exactly 30 seconds | _Leverage: @datadog/datadog-api-client (MetricsApi.listMetrics, TagsApi.listHostTags), datasource configuration for auth, design \"Datadog API Integration\" section | _Requirements: Requirements 2, 3, 4 (metric, aggregation, tag data fetching), Requirement 1 (debounce triggers these calls) | Success: Official client properly configured with timeouts, caching works correctly with TTL, auth errors handled gracefully, all functions typed and tested\n\n## Task 3: Implement useQueryAutocomplete hook\n\n- [ ] 5. Create src/hooks/useQueryAutocomplete.ts\n  - File: src/hooks/useQueryAutocomplete.ts (new)\n  - Implement React hook with debounce, state management, API orchestration\n  - Handle keyboard navigation (arrow up/down, escape, enter, tab)\n  - Purpose: Manage autocomplete state, debouncing, and UI interactions\n  - _Leverage: React hooks (useState, useEffect, useCallback, useRef), debounce utilities\n  - _Requirements: Requirement 1 (debounce), Requirements 2-4 (data fetching), Requirement 6 (keyboard navigation)\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: React developer specializing in custom hooks and state management | Task: Create src/hooks/useQueryAutocomplete.ts hook managing debounced autocomplete with 300-500ms delay, handling useState for suggestions/loading/errors, implementing keyboard navigation (arrow up/down cycles through items, Enter/Tab selects, Escape closes), canceling in-flight requests on debounce reschedule, and integrating parser/suggestions/api utilities from previous tasks | Restrictions: Debounce duration 300-500ms exactly as per design, max 5 concurrent requests, handle race conditions from multiple API calls | _Leverage: useQueryAutocomplete interface from design, parser.ts, suggestions.ts, api.ts from tasks 2-4, useCallback/useRef for debounce | _Requirements: Requirements 1, 2, 3, 4, 6 (debounce, all suggestions, keyboard nav) | Success: Debounce works reliably (tested with keystroke sequences), keyboard navigation responsive and intuitive, loading states display correctly, race conditions handled, hook integrates all utilities seamlessly\n\n## Task 4: Refactor QueryEditor component to functional hooks\n\n- [ ] 6. Refactor src/components/QueryEditor.tsx\n  - File: src/components/QueryEditor.tsx (modify existing)\n  - Convert PureComponent class to functional component with hooks\n  - Integrate useQueryAutocomplete hook\n  - Add autocomplete UI rendering with Grafana components\n  - Purpose: Display query input with integrated autocomplete dialog\n  - _Leverage: @grafana/ui (CodeEditor component if available, or custom input), useQueryAutocomplete hook, Grafana autocomplete dialog patterns\n  - _Requirements: Requirement 7 (Grafana-native UI), all suggestion requirements\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: React developer specializing in Grafana plugin UI components | Task: Refactor src/components/QueryEditor.tsx from PureComponent class to functional component using hooks, integrate useQueryAutocomplete from task 5, render Grafana-native autocomplete dialog showing suggestions on debounce trigger, display loading spinner during API calls, handle suggestion selection and insertion into query at cursor position, maintain backward compatibility with existing QueryEditorProps | Restrictions: Must use @grafana/ui components (CodeEditor, popover, or similar), preserve existing onChange/onRunQuery callbacks, don't break existing dashboard integrations | _Leverage: src/hooks/useQueryAutocomplete.ts from task 5, @grafana/ui autocomplete patterns, existing QueryEditor logic | _Requirements: Requirements 1-7 (all functionality integrated visually) | Success: Component renders with hooks pattern, autocomplete dialog appears after debounce, suggestions insert correctly, loading state displays, keyboard navigation works, all tests pass\n\n## Task 5: Add query validation with debounce\n\n- [ ] 7. Create src/utils/queryValidator.ts\n  - File: src/utils/queryValidator.ts (new)\n  - Implement validateQuery function for syntax and semantic validation\n  - Return validation errors with helpful messages\n  - Purpose: Provide real-time query validation feedback\n  - _Leverage: Parser utilities, query structure knowledge\n  - _Requirements: Requirement 5 (query validation)\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: TypeScript developer specializing in validation logic | Task: Create src/utils/queryValidator.ts with validateQuery function that checks Datadog query syntax (metric must exist, aggregation required if metric present, valid tag format), returns ValidationResult with errors array and isValid boolean, suggesting fixes for common issues | Restrictions: Validation must be synchronous and fast (<100ms), provide actionable error messages for users | _Leverage: parser.ts from task 2, parser output to understand query structure | _Requirements: Requirement 5 (validation with feedback) | Success: All query edge cases validated correctly, error messages are clear and helpful, performance meets <100ms target, unit tests cover success and failure scenarios\n\n- [ ] 8. Integrate validation into useQueryAutocomplete hook\n  - File: src/hooks/useQueryAutocomplete.ts (modify from task 5)\n  - Add validation on debounce expiry\n  - Display validation state in autocomplete UI\n  - Purpose: Show validation results alongside autocomplete suggestions\n  - _Leverage: queryValidator.ts from task 7, existing hook state\n  - _Requirements: Requirement 5 (validation feedback)\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: React developer | Task: Modify src/hooks/useQueryAutocomplete.ts to call validateQuery function on debounce expiry, add validationState to hook return type, display validation errors as red X or error message in autocomplete UI, show green checkmark when query is valid | Restrictions: Validation errors should not prevent running query, just inform user | _Leverage: queryValidator.ts from task 7, useQueryAutocomplete hook structure | _Requirements: Requirement 5 | Success: Validation displays correctly alongside suggestions, errors clear when user fixes issues, visual indicators obvious\n\n## Task 6: Unit and integration tests\n\n- [ ] 9. Create parser.ts unit tests\n  - File: tests/utils/autocomplete/parser.test.ts (new)\n  - Test parseQuery with various cursor positions\n  - Test context type detection\n  - Test edge cases\n  - Purpose: Verify parser reliability\n  - _Leverage: Jest, parser.ts from task 2\n  - _Requirements: Design \"Testing Strategy\" unit testing section\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA engineer specializing in unit testing | Task: Create comprehensive unit tests for src/utils/autocomplete/parser.ts testing all context types (metric, aggregation, tag, tag_value), cursor position variations, empty queries, special characters, and boundary conditions | Restrictions: Tests must be isolated, use Jest, achieve >90% code coverage | _Leverage: Jest testing framework, parser.ts | _Requirements: Design \"Testing Strategy\" unit testing | Success: All test cases pass, coverage >90%, edge cases thoroughly tested\n\n- [ ] 10. Create suggestions.ts unit tests\n  - File: tests/utils/autocomplete/suggestions.test.ts (new)\n  - Test generateSuggestions with mock data\n  - Test filtering and sorting\n  - Test duplicate removal\n  - Purpose: Verify suggestion generation\n  - _Leverage: Jest, suggestions.ts from task 3\n  - _Requirements: Design \"Testing Strategy\"\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA engineer | Task: Create unit tests for src/utils/autocomplete/suggestions.ts testing suggestion generation for all context types, filtering of duplicates, limiting to 100 items, filtering used tags | Restrictions: Use mocked data, Jest, >90% coverage | _Leverage: Jest, suggestions.ts | _Requirements: Design \"Testing Strategy\" | Success: All test cases pass, filtering logic verified, >90% coverage\n\n- [ ] 11. Create api.ts unit tests\n  - File: tests/utils/autocomplete/api.test.ts (new)\n  - Mock Datadog API client\n  - Test successful responses\n  - Test error handling and timeout\n  - Test caching\n  - Purpose: Verify API integration\n  - _Leverage: Jest, api.ts from task 4, mock-datadog-client\n  - _Requirements: Design \"Testing Strategy\"\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA engineer with API testing expertise | Task: Create unit tests for src/utils/autocomplete/api.ts mocking @datadog/datadog-api-client, testing successful metric/tag fetches, 2-second timeout scenarios, 401/403 auth errors, and 30-second cache TTL | Restrictions: Mock official client completely, test promise rejection, Jest | _Leverage: Jest with mocking, api.ts | _Requirements: Design \"Testing Strategy\" | Success: Mock setup works, all scenarios tested, caching TTL verified, >90% coverage\n\n- [ ] 12. Create hook integration tests\n  - File: tests/hooks/useQueryAutocomplete.test.ts (new)\n  - Test debounce behavior\n  - Test state transitions\n  - Test keyboard navigation\n  - Test suggestion selection\n  - Purpose: Verify hook functionality\n  - _Leverage: Jest, React Testing Library, useQueryAutocomplete from task 5\n  - _Requirements: Design \"Testing Strategy\"\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA engineer specializing in React testing | Task: Create tests for src/hooks/useQueryAutocomplete.ts using React Testing Library, testing debounce timing (300-500ms), state updates, keyboard navigation (arrow/escape/enter/tab), suggestion selection and insertion, error handling | Restrictions: Use React Testing Library best practices, mock API calls, Jest | _Leverage: React Testing Library, useQueryAutocomplete | _Requirements: Design \"Testing Strategy\" integration testing | Success: All interactions tested, debounce timing verified, >90% coverage, tests reflect user behavior\n\n- [ ] 13. Create QueryEditor component integration tests\n  - File: tests/components/QueryEditor.test.tsx (new)\n  - Test autocomplete appears after debounce\n  - Test suggestion insertion updates query\n  - Test keyboard and mouse interaction\n  - Purpose: Verify component integration with hook\n  - _Leverage: Jest, React Testing Library, QueryEditor from task 6\n  - _Requirements: Design \"Testing Strategy\" integration testing\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA engineer | Task: Create integration tests for src/components/QueryEditor.tsx testing autocomplete appearance after debounce, suggestion selection updates query correctly, keyboard navigation works, loading state displays | Restrictions: Use React Testing Library, mock useQueryAutocomplete, >90% coverage | _Leverage: React Testing Library, QueryEditor | _Requirements: Design \"Testing Strategy\" integration testing | Success: Component tests pass, user workflows verified, >90% coverage\n\n## Task 7: Documentation and finalization\n\n- [ ] 14. Create autocomplete documentation\n  - File: docs/autocomplete.md (new)\n  - Document API usage, architecture, configuration options\n  - Add examples and troubleshooting\n  - Purpose: Help users and developers understand feature\n  - _Leverage: Design document, code comments\n  - _Requirements: All requirements\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical writer | Task: Create comprehensive documentation in docs/autocomplete.md explaining autocomplete feature, architecture, how parser detects context, configuration of debounce timing and cache TTL, troubleshooting common issues | Restrictions: Clear and accessible language | _Leverage: Design document, actual implementation | _Requirements: All | Success: Documentation is clear, complete, and helpful to developers\n\n- [ ] 15. Final code review and cleanup\n  - Review all code for quality, consistency, types\n  - Ensure all tests pass\n  - Clean up any debug code\n  - Update CHANGELOG.md\n  - Purpose: Ensure production-ready implementation\n  - _Leverage: ESLint, TypeScript compiler, existing code style\n  - _Requirements: All\n  - _Prompt: Implement the task for spec query-editor-autocomplete, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior developer | Task: Review all autocomplete code for TypeScript strictness, consistency with project patterns, remove debug code, run full test suite, update CHANGELOG.md with new feature, ensure code follows project style | Restrictions: No breaking changes, maintain backward compatibility, all tests must pass | _Leverage: Existing linting/TypeScript config, project conventions | _Requirements: All | Success: Code review complete, all tests pass, linting clean, CHANGELOG updated, ready for release\n",
  "fileStats": {
    "size": 19752,
    "lines": 171,
    "lastModified": "2025-12-05T10:11:51.759Z"
  },
  "comments": []
}