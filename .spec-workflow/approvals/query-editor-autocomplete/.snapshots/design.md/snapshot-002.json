{
  "id": "snapshot_1764929117567_6q85y6zoy",
  "approvalId": "approval_1764928910433_ckv92bqyv",
  "approvalTitle": "Query Editor Autocomplete - Design Document",
  "version": 2,
  "timestamp": "2025-12-05T10:05:17.567Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Design Document: Query Editor Autocomplete\n\n## Overview\n\nThis document describes the technical design for adding intelligent autocomplete functionality to the Grafana Datadog datasource query editor. The feature will provide context-aware suggestions for metric names, aggregation functions, and tags with a 300-500ms debounce delay. The design leverages Grafana's built-in autocomplete dialog UI component and integrates with the existing Datadog API infrastructure.\n\n## Steering Document Alignment\n\n### Technical Standards\n\nThe plugin follows Grafana's standard patterns for datasource plugins (v12.3.0). Our design aligns with these patterns:\n- Use of `@grafana/data` and `@grafana/ui` components\n- React 19 with hooks and functional components (migrating from PureComponent)\n- TypeScript with strict typing\n- Proper use of `getBackendSrv()` for API calls\n- Support for template variable interpolation via `getTemplateSrv()`\n\n### Project Structure\n\nThe implementation will follow the existing file organization:\n- Components: `src/QueryEditor.tsx` (refactored)\n- Hooks: `src/hooks/useQueryAutocomplete.ts` (new)\n- Utilities: `src/utils/autocomplete/` (new directory)\n  - `src/utils/autocomplete/parser.ts` - Query parsing and context detection\n  - `src/utils/autocomplete/suggestions.ts` - Suggestion generation logic\n  - `src/utils/autocomplete/api.ts` - Datadog API integration for suggestions\n- Types: `src/types.ts` (extended)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`QueryEditor.tsx`**: The existing component will be refactored to use hooks instead of PureComponent class pattern, integrating the autocomplete hook\n- **`datasource.ts`**: Existing methods like `fetchMetricNames()` and `metricFindQuery()` will be extracted and reused for suggestion fetching\n- **Grafana UI `CompletionItem` & `CodeEditor`**: Will use Grafana's built-in autocomplete dialog components for consistency\n- **`getBackendSrv()`**: Existing API call mechanism will be used for suggestion fetching\n- **`getTemplateSrv()`**: Template variable replacement will be applied to autocomplete context\n\n### Integration Points\n\n- **Datadog API Integration**: Leverage existing Datadog API routes defined in `plugin.json` to fetch metrics and tags\n- **Query State Management**: Work with existing `MyQuery` interface for query text storage\n- **Datasource Instance**: Access datasource instance for API routes and configuration\n- **Variable Interpolation**: Support Grafana dashboard variables in metric and tag contexts\n\n## Architecture\n\nThe autocomplete feature is designed with a layered, modular architecture:\n\n```\nQueryEditor (UI Layer)\n    ↓\nuseQueryAutocomplete Hook (State Management)\n    ├─ Debounce Logic\n    ├─ State Management\n    └─ API Orchestration\n        ↓\nSuggestion Engine (Business Logic)\n    ├─ parser.ts (Query context analysis)\n    ├─ suggestions.ts (Suggestion generation)\n    └─ api.ts (Datadog API calls)\n        ↓\nDatadog API (External Service)\n    ├─ Metrics endpoint\n    └─ Tags endpoint\n```\n\n### Modular Design Principles\n\n1. **Single File Responsibility**:\n   - `parser.ts`: Only responsible for parsing queries and detecting cursor context\n   - `suggestions.ts`: Only generates suggestion lists from parsed data\n   - `api.ts`: Only handles API calls and response transformation\n   - `useQueryAutocomplete.ts`: Only manages autocomplete state and debounce timing\n\n2. **Component Isolation**:\n   - Autocomplete logic is completely separate from rendering\n   - Suggestion fetching is isolated in utility functions\n   - UI component remains focused on display only\n\n3. **Service Layer Separation**:\n   - Data Access: `api.ts` handles all Datadog API communication\n   - Business Logic: `parser.ts` and `suggestions.ts` handle context analysis and suggestion generation\n   - Presentation: `QueryEditor.tsx` handles rendering and user interaction\n\n4. **Utility Modularity**:\n   - Each utility has a single, clear purpose\n   - No cross-cutting concerns within utilities\n   - All functions are pure and testable\n\n## Components and Interfaces\n\n### Component 1: `useQueryAutocomplete` Hook\n\n- **Purpose**: Manages autocomplete state, debouncing, and API calls\n- **Interfaces**:\n  ```typescript\n  interface AutocompleteState {\n    isOpen: boolean;\n    suggestions: CompletionItem[];\n    isLoading: boolean;\n    selectedIndex: number;\n    error?: string;\n  }\n  \n  function useQueryAutocomplete(\n    query: string,\n    queryText: string | undefined,\n    cursor: { line: number; ch: number }\n  ): {\n    state: AutocompleteState;\n    onItemSelect: (item: CompletionItem) => void;\n    onNavigate: (direction: 'up' | 'down') => void;\n    onClose: () => void;\n  }\n  ```\n- **Dependencies**: `datasource` instance, debounce utilities\n- **Reuses**: Existing `datasource.fetchMetricNames()` and API utilities\n\n### Component 2: `QueryEditor` (Refactored)\n\n- **Purpose**: React component for query input with integrated autocomplete UI\n- **Interfaces**:\n  ```typescript\n  interface QueryEditorProps {\n    query: MyQuery;\n    onChange: (query: MyQuery) => void;\n    onRunQuery: () => void;\n    datasource: DataSource;\n  }\n  ```\n- **Dependencies**: `useQueryAutocomplete` hook, Grafana UI components\n- **Reuses**: Existing `TextArea` input, label rendering logic\n\n### Component 3: Suggestion Utilities\n\n- **Purpose**: Provide pure functions for parsing and generating suggestions\n- **Interfaces**:\n  ```typescript\n  // parser.ts\n  interface QueryContext {\n    cursorPosition: number;\n    currentToken: string;\n    contextType: 'metric' | 'aggregation' | 'tag' | 'tag_value' | 'other';\n    metricName?: string;\n    existingTags: string[];\n  }\n  \n  function parseQuery(queryText: string, cursorPosition: number): QueryContext\n  \n  // suggestions.ts\n  function generateSuggestions(\n    context: QueryContext,\n    metrics: string[],\n    tagsForMetric: string[],\n    existingSuggestions?: CachedSuggestions\n  ): CompletionItem[]\n  \n  // api.ts\n  function fetchSuggestionsForMetric(\n    datasource: DataSource,\n    metricName: string\n  ): Promise<{ tags: string[]; aggregations: string[] }>\n  ```\n- **Dependencies**: None (pure functions)\n- **Reuses**: Type definitions from `types.ts`\n\n## Data Models\n\n### CompletionItem (from Grafana)\n```typescript\ninterface CompletionItem {\n  label: string;           // Display text\n  kind?: string;          // 'metric' | 'aggregation' | 'tag' | 'tag_value'\n  detail?: string;        // Additional info shown in dropdown\n  insertText: string;     // Text to insert when selected\n  sortText?: string;      // Used for sorting suggestions\n  documentation?: string; // Hover text\n  range?: {\n    startLine: number;\n    startCharacter: number;\n    endLine: number;\n    endCharacter: number;\n  };\n}\n```\n\n### QueryContext (Internal)\n```typescript\ninterface QueryContext {\n  cursorPosition: number;\n  currentToken: string;\n  contextType: 'metric' | 'aggregation' | 'tag' | 'tag_value' | 'other';\n  metricName?: string;\n  existingTags: Set<string>;\n  lineContent: string;\n}\n```\n\n### AutocompleteCache\n```typescript\ninterface AutocompleteCache {\n  metricSuggestions: Map<string, { data: CompletionItem[]; timestamp: number }>;\n  tagSuggestions: Map<string, { data: string[]; timestamp: number }>;\n  TTL: number; // 30 seconds\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Datadog API Timeout (>2 seconds)**\n   - **Handling**: Cancel request, show timeout message, allow manual entry\n   - **User Impact**: User sees \"Suggestions loading...\" message that clears after timeout\n\n2. **Network Error / API Failure**\n   - **Handling**: Log error, close autocomplete, show warning tooltip\n   - **User Impact**: Autocomplete closes, user can continue typing manually\n\n3. **Invalid Query Context**\n   - **Handling**: Skip suggestion generation, return empty list\n   - **User Impact**: No suggestions shown for invalid cursor positions\n\n4. **Unauthorized / Invalid Credentials**\n   - **Handling**: Show authentication error in autocomplete instead of suggestions\n   - **User Impact**: User is prompted to verify datasource credentials\n\n5. **Memory/Performance Issues (too many suggestions)**\n   - **Handling**: Limit suggestions to top 100 items, implement virtualization\n   - **User Impact**: Scrollable list, responsive keyboard navigation\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Query Parser Tests** (`parser.ts`):\n  - Parse metric names at various cursor positions\n  - Detect aggregation function context\n  - Identify tag filter context\n  - Handle edge cases (empty queries, special characters)\n\n- **Suggestion Generator Tests** (`suggestions.ts`):\n  - Generate correct completions for metric context\n  - Generate correct completions for aggregation context\n  - Filter duplicate suggestions\n  - Handle metric names with special characters\n\n- **Hook Tests** (`useQueryAutocomplete.ts`):\n  - Debounce triggers after 300-500ms of inactivity\n  - Cancel previous debounce on new input\n  - Navigation between suggestions\n  - Selection and insertion of completions\n\n### Integration Testing\n\n- **API Integration Tests** (`api.ts`):\n  - Fetch metrics from Datadog API successfully\n  - Handle API errors gracefully\n  - Cache responses correctly\n  - Cache expiration works as expected\n\n- **QueryEditor Integration**:\n  - Autocomplete appears on debounce timeout\n  - Keyboard navigation closes and opens autocomplete\n  - Selected item inserts into query correctly\n  - Multiple selections in same query work correctly\n\n### End-to-End Testing\n\n- **User Workflows**:\n  1. Type metric name → autocomplete appears → select metric → aggregation suggestions appear\n  2. Type aggregation → tag filter context → select tags → query executes successfully\n  3. Keyboard-only navigation through autocomplete\n  4. API timeout scenario → graceful fallback\n  5. Empty query → initial metric suggestions appear\n\n## Datadog API Integration\n\n### Existing API Routes (from plugin.json)\n```\n/api/v1/query - Query metrics\n/api/v2/metrics/{metric_name}/all-tags - Get tags for metric\n/api/v1/tags/hosts - Get host tags\n```\n\n### New Suggestion Endpoints Needed\n- List all available metrics (may need to implement server-side)\n- Get aggregations for a metric (can be static list or API-driven)\n\nThe plugin backend (if applicable) may need enhancement to provide:\n- Paginated metric list endpoint\n- Aggregation options endpoint\n\n## Performance Considerations\n\n1. **Debounce Duration**: 300-500ms strikes balance between responsiveness and API load\n2. **Caching**: 30-second TTL cache for metric and tag suggestions\n3. **API Limiting**: Max 5 concurrent suggestion requests\n4. **Suggestion Limiting**: Display max 100 suggestions with virtualization\n5. **Query Parsing**: Simple regex-based parser (<10ms execution time)\n\n## Migration Path from PureComponent to Hooks\n\nThe `QueryEditor` component will be refactored from `PureComponent` to a functional component using hooks:\n\n**Before:**\n```typescript\nexport class QueryEditor extends PureComponent<Props>\n```\n\n**After:**\n```typescript\nexport function QueryEditor({ query, onChange, onRunQuery, datasource }: Props)\n```\n\nThis modernizes the codebase to match Grafana's current patterns while maintaining backward compatibility.\n",
  "fileStats": {
    "size": 11228,
    "lines": 318,
    "lastModified": "2025-12-05T10:01:46.924Z"
  },
  "comments": []
}